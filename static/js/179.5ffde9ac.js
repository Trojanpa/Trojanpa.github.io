"use strict";(self["webpackChunkthree_demo2"]=self["webpackChunkthree_demo2"]||[]).push([[179],{1179:function(t,e,n){n.r(e),n.d(e,{default:function(){return b}});var s=function(){var t=this,e=t.$createElement;t._self._c;return t._m(0)},i=[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"demo14"},[n("div",{attrs:{id:"demo14Id"}}),n("div",{attrs:{id:"stats14Id"}})])}],r=n(9365),o=n(9477);const a=0,h=1,l=new o.Pa4,c=new o.Zzh,d=new o.JOQ,u=new o.Pa4,p=new o.CJI;class m{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new g,this.unassigned=new g,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new f(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse((function(t){const n=t.geometry;if(void 0!==n){if(n.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(n.isBufferGeometry){const s=n.attributes.position;if(void 0!==s)for(let n=0,i=s.count;n<i;n++){const i=new o.Pa4;i.fromBufferAttribute(s,n).applyMatrix4(t.matrixWorld),e.push(i)}}}})),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.distanceToPoint(t)>this.tolerance)return!1}return!0}intersectRay(t,e){const n=this.faces;let s=-1/0,i=1/0;for(let r=0,o=n.length;r<o;r++){const e=n[r],o=e.distanceToPoint(t.origin),a=e.normal.dot(t.direction);if(o>0&&a>=0)return null;const h=0!==a?-o/a:0;if(!(h<=0)&&(a>0?i=Math.min(h,i):s=Math.max(h,s),s>i))return null}return s!==-1/0?t.at(s,e):t.at(i,e),e}intersectsRay(t){return null!==this.intersectRay(t,l)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let n=t.outside;while(null!==n.next&&n.next.face===t)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(void 0!==n)if(void 0===e)this.unassigned.appendChain(n);else{let t=n;do{const n=t.next,s=e.distanceToPoint(t.point);s>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=n}while(null!==t)}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{const n=e.next;let s=this.tolerance,i=null;for(let r=0;r<t.length;r++){const n=t[r];if(n.mark===a){const t=n.distanceToPoint(e.point);if(t>s&&(s=t,i=n),s>1e3*this.tolerance)break}}null!==i&&this.addVertexToFace(e,i),e=n}while(null!==e)}return this}computeExtremes(){const t=new o.Pa4,e=new o.Pa4,n=[],s=[];for(let i=0;i<3;i++)n[i]=s[i]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let i=0,r=this.vertices.length;i<r;i++){const r=this.vertices[i],o=r.point;for(let e=0;e<3;e++)o.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,o.getComponent(e)),n[e]=r);for(let t=0;t<3;t++)o.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,o.getComponent(t)),s[t]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:s}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,s=e.max;let i=0,r=0;for(let c=0;c<3;c++){const t=s[c].point.getComponent(c)-n[c].point.getComponent(c);t>i&&(i=t,r=c)}const o=n[r],a=s[r];let h,l;i=0,c.set(o.point,a.point);for(let d=0,m=this.vertices.length;d<m;d++){const e=t[d];if(e!==o&&e!==a){c.closestPointToPoint(e.point,!0,u);const t=u.distanceToSquared(e.point);t>i&&(i=t,h=e)}}i=-1,d.setFromCoplanarPoints(o.point,a.point,h.point);for(let c=0,u=this.vertices.length;c<u;c++){const e=t[c];if(e!==o&&e!==a&&e!==h){const t=Math.abs(d.distanceToPoint(e.point));t>i&&(i=t,l=e)}}const p=[];if(d.distanceToPoint(l.point)<0){p.push(x.create(o,a,h),x.create(l,a,o),x.create(l,h,a),x.create(l,o,h));for(let t=0;t<3;t++){const e=(t+1)%3;p[t+1].getEdge(2).setTwin(p[0].getEdge(e)),p[t+1].getEdge(1).setTwin(p[e+1].getEdge(0))}}else{p.push(x.create(o,h,a),x.create(l,o,a),x.create(l,a,h),x.create(l,h,o));for(let t=0;t<3;t++){const e=(t+1)%3;p[t+1].getEdge(2).setTwin(p[0].getEdge((3-t)%3)),p[t+1].getEdge(0).setTwin(p[e+1].getEdge(1))}}for(let c=0;c<4;c++)this.faces.push(p[c]);for(let c=0,d=t.length;c<d;c++){const e=t[c];if(e!==o&&e!==a&&e!==h&&e!==l){i=this.tolerance;let t=null;for(let n=0;n<4;n++){const s=this.faces[n].distanceToPoint(e.point);s>i&&(i=s,t=this.faces[n])}null!==t&&this.addVertexToFace(e,t)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const n=this.faces[e];n.mark===a&&t.push(n)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const n=this.assigned.first().face;let s=n.outside;do{const i=n.distanceToPoint(s.point);i>e&&(e=i,t=s),s=s.next}while(null!==s&&s.face===n);return t}}computeHorizon(t,e,n,s){let i;this.deleteFaceVertices(n),n.mark=h,i=null===e?e=n.getEdge(0):e.next;do{const e=i.twin,n=e.face;n.mark===a&&(n.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,e,n,s):s.push(i)),i=i.next}while(i!==e);return this}addAdjoiningFace(t,e){const n=x.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,s=null;for(let i=0;i<e.length;i++){const r=e[i],o=this.addAdjoiningFace(t,r);null===n?n=o:o.next.setTwin(s),this.newFaces.push(o.face),s=o}return n.next.setTwin(s),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;this.computeInitialHull();while(void 0!==(t=this.nextVertexToAdd()))this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class x{constructor(){this.normal=new o.Pa4,this.midpoint=new o.Pa4,this.area=0,this.constant=0,this.outside=null,this.mark=a,this.edge=null}static create(t,e,n){const s=new x,i=new w(t,s),r=new w(e,s),o=new w(n,s);return i.next=o.prev=r,r.next=i.prev=o,o.next=r.prev=i,s.edge=i,s.compute()}getEdge(t){let e=this.edge;while(t>0)e=e.next,t--;while(t<0)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return p.set(t.point,e.point,n.point),p.getNormal(this.normal),p.getMidpoint(this.midpoint),this.area=p.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class w{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class f{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class g{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;while(null!==t.next)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}class v extends o.u9r{constructor(t=[]){super();const e=[],n=[];void 0===m&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const s=(new m).setFromPoints(t),i=s.faces;for(let r=0;r<i.length;r++){const t=i[r];let s=t.edge;do{const i=s.head().point;e.push(i.x,i.y,i.z),n.push(t.normal.x,t.normal.y,t.normal.z),s=s.next}while(s!==t.edge)}this.setAttribute("position",new o.a$l(e,3)),this.setAttribute("normal",new o.a$l(n,3))}}var E=n(3466),P=n.n(E),M=n(4376),F={name:"Demo14",data(){return{scene:null,camera:null,renderer:null,axes:null,convexGeo:null,convexMat:null,convex:null,latheGeo:null,latheMat:null,lathe:null,stats:null,controls:null}},mounted(){this.init(),window.addEventListener("resize",this.onWindowResize.bind(this))},methods:{init(){this.scene=new o.xsS,this.camera=new o.cPb(75,window.innerWidth/window.innerHeight/2,.1,1e3),this.renderer=new o.CP7,this.renderer.setClearColor(new o.Ilk(0)),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.shadowMap.enabled=!0,document.getElementById("demo14Id").appendChild(this.renderer.domElement),this.axes=new o.y8_(50),this.scene.add(this.axes);const t=[];for(let r=0;r<20;r++){const e=40*Math.random()-20,n=40*Math.random()-20,s=40*Math.random()-20;t.push(new o.Pa4(e,n,s))}t.forEach((t=>{const e=new o.xo$(.3),n=new o.vBJ({color:16711680}),s=new o.Kj0(e,n);s.position.copy(t),s.translateX(-30),this.scene.add(s)})),this.convexGeo=new v(t),this.convexMat=new o.vBJ({color:65280,wireframe:!0}),this.convex=new o.Kj0(this.convexGeo,this.convexMat),this.convex.translateX(-30),this.scene.add(this.convex);const e=[];for(let r=5;r<30;r++)e.push(new o.FM8(r+1,10*-Math.sin((r+1)/10)-10*Math.cos((r+1)/10)));this.latheGeo=new o.p7y(e,50,0,2*Math.PI),this.latheMat=new o.vBJ({color:65280,wireframe:!0}),this.lathe=new o.Kj0(this.latheGeo,this.latheMat),this.lathe.translateX(30),this.scene.add(this.lathe);const n={segments:4,phiStart:8,phiLength:2*Math.PI},s=new M.ZP.GUI,i=s.addFolder("lathe");i.add(n,"segments",1,100).onChange((t=>{this.editLathe(n,e)})),i.add(n,"phiStart",0,2*Math.PI).onChange((t=>{this.editLathe(n,e)})),i.add(n,"phiLength",0,2*Math.PI).onChange((t=>{this.editLathe(n,e)})),this.camera.position.x=0,this.camera.position.y=0,this.camera.position.z=100,this.camera.lookAt(this.scene.position),this.scene.add(this.camera),this.addStats(),this.createControls(),this.renderScene()},renderScene(){this.stats.update(),this.controls.update(),requestAnimationFrame(this.renderScene),this.renderer.render(this.scene,this.camera)},addStats(){this.stats=new(P()),this.stats.domElement.style.position="absolute",this.stats.domElement.style.left="0px",this.stats.domElement.style.top="0px",this.stats.setMode(0),document.getElementById("stats14Id").appendChild(this.stats.domElement)},onWindowResize(t){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight)},createControls(){this.controls=new r.z(this.camera,this.renderer.domElement),this.controls.update()},editLathe(t,e){this.scene.remove(this.lathe),this.latheGeo=new o.p7y(e,t.segments,t.phiStart,t.phiLength),this.lathe=new o.Kj0(this.latheGeo,this.latheMat),this.lathe.translateX(30),this.scene.add(this.lathe)}}},T=F,y=n(1001),C=(0,y.Z)(T,s,i,!1,null,"3dde1dad",null),b=C.exports}}]);